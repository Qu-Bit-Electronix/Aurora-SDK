\label{index_md_README}%
\Hypertarget{index_md_README}%
 \href{https://github.com/Qu-Bit-Electronix/Aurora-SDK/actions/workflows/main.yml}{\texttt{ }} \href{https://Qu-Bit-Electronix.github.io/Aurora-SDK}{\texttt{ }}

Everything you need to start writing your own application for the Qu-\/\+Bit Aurora Hardware platform!

Check out the \href{Qu-Bit-Electronix.github.io/Aurora-SDK}{\texttt{ reference documentation}} for the project.

Below we\textquotesingle{}ll cover some basic topics to get started writing your own code to run on the Aurora\hypertarget{index_autotoc_md1}{}\doxysection{Table of Contents}\label{index_autotoc_md1}

\begin{DoxyItemize}
\item \href{\#reading-and-running-examples}{\texttt{ Reaing and Running Examples}}
\begin{DoxyItemize}
\item \href{\#blink}{\texttt{ Blink}}
\item \href{\#volume}{\texttt{ Volume}}
\item \href{\#ringmod}{\texttt{ Ringmod}}
\end{DoxyItemize}
\item \href{\#compiling-the-examples}{\texttt{ Compiling the Examples}}
\begin{DoxyItemize}
\item \href{\#installing-the-toolchain}{\texttt{ Installing the Toolchain}}
\item \href{\#cloning-the-sdk}{\texttt{ Cloning the SDK}}
\item \href{\#building-the-libraries}{\texttt{ Building the Libraries}}
\item \href{\#building-the-examples}{\texttt{ Building the Examples}}
\end{DoxyItemize}
\item \href{\#going-further}{\texttt{ Going Further}}
\begin{DoxyItemize}
\item \href{\#copying-and-modifying-an-example}{\texttt{ Copying and Modifying an Example}}
\item \href{\#creating-your-own-firmware-project}{\texttt{ Creating Your Own Firmware Project}}
\item \href{\#sharing-firmware-with-the-community}{\texttt{ Sharing Firmware With the Community}}
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{index_autotoc_md2}{}\doxysection{Reading and Running Examples}\label{index_autotoc_md2}
One of the best ways to see how stuff works is to try it out!

In the {\ttfamily dist/\+Examples} folder is a precompiled version of each of the available examples, and the {\ttfamily Examples/} folder has the corresponding source code.

Before we get into installing any tools or anything, let\textquotesingle{}s take a moment to look over some of the basic examples, and see how to interact with the module hardware in C++ (it\textquotesingle{}s easier than you might think)!

To load one of the examples just drag the .bin file of your choice onto your USB drive, and power up the Aurora with it inserted.

{\bfseries{Note}}\+: In order to ensure that you\textquotesingle{}re loading the desired program, you should have only one {\ttfamily .bin} file in the root directory of the USB drive. (you can keep as many as you want in folders, though!)

The most up to date, official Aurora firmware can always be downloaded from \href{https://www.qubitelectronix.com/shop/aurora}{\texttt{ the Aurora product page}}\hypertarget{index_autotoc_md3}{}\doxysubsection{Blink}\label{index_autotoc_md3}
In this example, we\textquotesingle{}re just periodically changing the state of an LED. No audio, no controls.

Here, we can see a few things that will happen in every program\+:

We always have a {\ttfamily Hardware} object, that\textquotesingle{}s our connection to the module itself. Typically, we\textquotesingle{}ll name it {\ttfamily hw} to keep it nice and short.

We can use that to do things, for example, in this example, we change the state of an LED\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{hw.SetLed(\mbox{\hyperlink{namespaceaurora_a9a9c6ab298a74678c30dc9d3947d8e1eae68413e53d500917bb75e2cae59f3730}{LED\_FREEZE}}, 0.f, 0.f, led\_state);}

\end{DoxyCode}


where the arguments are the LED we want to change followed by values for the red, green, and blue components of the light.

Next, we toggle that state by changing the variable.

Then we tell the hardware to write all changes to the LED values to the actual hardware\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{hw.WriteLeds();}

\end{DoxyCode}


Finally, we tell tell everything to wait 500 milliseconds (or 0.\+5 seconds) before looping back to the top of the infinite loop\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{System::Delay(500);}

\end{DoxyCode}


Check out the \href{https://github.com/Qu-Bit-Electronix/Aurora-SDK/blob/main/Examples/Blink/Blink.cpp}{\texttt{ full example code here}}

In more complex projects we\textquotesingle{}ll want to avoid using delays, but we\textquotesingle{}ll get into techniques for doing that later.\hypertarget{index_autotoc_md4}{}\doxysubsection{Volume}\label{index_autotoc_md4}
In this example, we\textquotesingle{}re going to add two new things to what our previous example did\+: audio, and knobs!

That\textquotesingle{}s right, the most exciting eurorack concept ever invented -- a volume control.

Just like in our last example, we\textquotesingle{}re still going to create our {\ttfamily Hardware} object, and initialize it.

However, now we\textquotesingle{}re going to start up a new \char`\"{}callback\char`\"{} for handling audio.

To define the the audio callback we write a function like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{void} AudioCallback(AudioHandle::InputBuffer in, AudioHandle::OutputBuffer out, \textcolor{keywordtype}{size\_t} size)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\}}

\end{DoxyCode}


The function can have any name, but for clarity we\textquotesingle{}ll simply call it {\ttfamily Audio\+Callback} within the example.

The three arguments are\+:


\begin{DoxyItemize}
\item in\+: real time stereo audio input from the hardware
\item out\+: real time stereo audio output from the hardware
\item size\+: the number of individual samples included in the buffers
\end{DoxyItemize}

The audio default audio configuration is set up with an array of samples per channel, like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{    \{ L0, L1, L2, . . ., LN \},}
\DoxyCodeLine{    \{ R0, R1, R2, . . ., RN \}}
\DoxyCodeLine{\}}

\end{DoxyCode}


So using these arguments, we can loop over each sample of audio, individually.

For example, just passing the input straight through to the output\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < size; i++)}
\DoxyCodeLine{\{}
\DoxyCodeLine{    out[0][i] = in[0][i];}
\DoxyCodeLine{    out[1][i] = in[1][i];}
\DoxyCodeLine{\}}

\end{DoxyCode}


We want {\bfseries{control}}, through. So what we want to do is use the value of one of the knobs to scale that level.

Thie is pretty easy to setup. Within the callback, we\textquotesingle{}ll want to process all of our controls, and then we can simply assign one of them to a variable called, \char`\"{}volume\char`\"{}.

Here we\textquotesingle{}ll use the mix knob to get a 0-\/1 value.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{void} AudioCallback(AudioHandle::InputBuffer in, AudioHandle::OutputBuffer out, \textcolor{keywordtype}{size\_t} size)}
\DoxyCodeLine{\{}
\DoxyCodeLine{    hw.ProcessAllControls();}
\DoxyCodeLine{    \textcolor{keywordtype}{float} volume = hw.GetKnobValue(\mbox{\hyperlink{namespaceaurora_afd0b5d0be3c1f756f0396bd2b2cbcecaa4030ec072fbbcc5198927f787fc381ae}{KNOB\_MIX}});}
\DoxyCodeLine{\}}

\end{DoxyCode}


Knobs and CVs are handled separately to allow for more complex user interfaces, but there is an equivalent {\ttfamily Get\+Cv\+Value} function that works in the same way.

Within the {\ttfamily for} loop, we can scale the input by this amount to control the volume of our signal.

In total, we now have the following Audio Callback\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{void} AudioCallback(AudioHandle::InputBuffer in, AudioHandle::OutputBuffer out, \textcolor{keywordtype}{size\_t} size)}
\DoxyCodeLine{\{}
\DoxyCodeLine{    hw.ProcessAllControls();}
\DoxyCodeLine{    \textcolor{keywordtype}{float} volume = hw.GetKnobValue(\mbox{\hyperlink{namespaceaurora_afd0b5d0be3c1f756f0396bd2b2cbcecaa4030ec072fbbcc5198927f787fc381ae}{KNOB\_MIX}});}
\DoxyCodeLine{    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < size; i++)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        out[0][i] = in[0][i] * volume;}
\DoxyCodeLine{        out[1][i] = in[1][i] * volume;}
\DoxyCodeLine{    \}}
\DoxyCodeLine{\}}

\end{DoxyCode}


For a bit more detail on how audio works on the Daisy, check out the \href{https://electro-smith.github.io/libDaisy/md_doc_md__a3__getting__started__audio.html}{\texttt{ Getting Started -\/ Audio}} guide.

And check out the \href{https://github.com/Qu-Bit-Electronix/Aurora-SDK/blob/main/Examples/Volume/Volume.cpp}{\texttt{ full example code here}}\hypertarget{index_autotoc_md5}{}\doxysubsection{Ringmod}\label{index_autotoc_md5}
In this example, we\textquotesingle{}re going to take what we learned in the Volume example, and make something a bit more exciting happen.

A ring modulator is a form of bipolar amplitude modulation that can be easily made by multiplying one signal (like our input signal), and another signal.

In this example we\textquotesingle{}re going to break out a few things from the Daisy\+SP DSP library.

We\textquotesingle{}ll also be using the {\ttfamily fmap} utility function to help us scale our control\textquotesingle{}s 0-\/1 values to a more desirable range for our controls.

For example, when setting our modulator frequency we\textquotesingle{}ll want to have a logarthmic curve, and a frequency range from say, 10Hz to 1.\+5k\+Hz. Using {\ttfamily fmap} we can save ourselves from figuring out how to do that with math.

The fmap function take up to 4 arguments\+:


\begin{DoxyEnumerate}
\item The 0-\/1 input to be converted (here we use {\ttfamily hw.\+Get\+Knob\+Value(\+KNOB\+\_\+\+WARP)})
\item The new minimum
\item The new maximum
\item The curve for the mapping function. If this isn\textquotesingle{}t specified, it defaults to a normal, linear curve.
\end{DoxyEnumerate}


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{float} freq = fmap(hw.GetKnobValue(\mbox{\hyperlink{namespaceaurora_afd0b5d0be3c1f756f0396bd2b2cbcecaa132e93ba27b993bd7bc17d340be96928}{KNOB\_WARP}}), 10.0, 1500.0, Mapping::LOG);}

\end{DoxyCode}


We\textquotesingle{}ll also be using an {\ttfamily Oscillator} to generate a sine wave for our modulator.

The {\ttfamily Oscillator}, like nearly every other Daisy\+SP object, has two core functions\+: {\ttfamily Init} and {\ttfamily Process}.

We want to initialize the oscillator, and set any particular parameters after initializing our Hardware object\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{osc.Init(hw.AudioSampleRate());}
\DoxyCodeLine{osc.SetWaveform(Oscillator::WAVE\_SIN);}
\DoxyCodeLine{osc.SetAmp(1.0);}

\end{DoxyCode}


And then within our per-\/sample loop of the audio callback, we can render the oscillator\textquotesingle{}s signal by calling it\textquotesingle{}s {\ttfamily Process} function.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < size; i++) \{}
\DoxyCodeLine{    \textcolor{keywordtype}{float} signal = osc.Process();}
\DoxyCodeLine{\}}

\end{DoxyCode}


To do the actual ring modulation effect, we\textquotesingle{}ll multiply that signal by our input signal.

Check out the \href{https://github.com/Qu-Bit-Electronix/Aurora-SDK/blob/main/Examples/Ringmod/Ringmod.cpp}{\texttt{ full example code here}}\hypertarget{index_autotoc_md6}{}\doxysection{Compiling the Examples}\label{index_autotoc_md6}
Now that we\textquotesingle{}ve covered the basics of working with the Daisy in C++. We\textquotesingle{}ll want to start making changes to the examples, and creating our own other-\/wordly effects.

Overall, this process is pretty simple, regardless of what operating system you\textquotesingle{}re using.\hypertarget{index_autotoc_md7}{}\doxysubsection{Installing the Toolchain}\label{index_autotoc_md7}
The \char`\"{}toolchain\char`\"{} is a bundle of tools used to take the source code, and turn it into a binary file that can load onto the Aurora (or any other Daisy) hardware.

If you\textquotesingle{}ve already done some development with Daisy in the past, you should already be good to go, and can skip ahead to the next section.

On any operating system, our recommended text editor is VS Code, but you can work in any environment you\textquotesingle{}re comfortable with. That said, we will only cover the specifics of working with VS Code in this guide.\hypertarget{index_autotoc_md8}{}\doxysubsubsection{Windows}\label{index_autotoc_md8}

\begin{DoxyEnumerate}
\item Download, and run the \mbox{[}Daisy Toolchain for Windows installer\mbox{]}() from Qu-\/bit website.
\item Download, and run the \href{https://git-scm.com/download/win}{\texttt{ Git for Windows installer}}.
\end{DoxyEnumerate}

This installs the required tools to get up and running with daisy.

There are some additional helper scripts that require python, but this is optional.

On Windows, you can install python by downloading the latest from \href{https://www.python.org/downloads/}{\texttt{ python.\+org}}.

{\bfseries{Note}}\+: The windows store version of python will not work.\hypertarget{index_autotoc_md9}{}\doxysubsubsection{Mac OS}\label{index_autotoc_md9}

\begin{DoxyEnumerate}
\item Download the \mbox{[}Daisy Toolchain for Mac OS installer\mbox{]}() from the Qu-\/\+Bit website.
\item Unzip, and Double click, the {\ttfamily install.\+command} file contained within.
\end{DoxyEnumerate}

There are some additional helper scripts that require python, but this is optional.

Mac OS comes with python, but the latest version can be downloaded from \href{https://www.python.org/downloads/}{\texttt{ python.\+org}}, or using homebrew.\hypertarget{index_autotoc_md10}{}\doxysubsection{Cloning the SDK}\label{index_autotoc_md10}
The Aurora-\/\+SDK is a github repo, and it uses a few libraries to provide access to the hardware, and bundles the \href{https://github.com/electro-smith/DaisySP}{\texttt{ Daisy\+SP}} DSP library.

To download the entire SDK with all of its libraries\+:

First, open a terminal, and navigate to the desired location on your computer. For our purposes here we\textquotesingle{}ll use the {\ttfamily Desktop} folder, but you may wish to use {\ttfamily Documents}, {\ttfamily Developer}, or some other folder of your choice.

Now, paste the following command into the terminal and press enter\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{git clone https://github.com/qu-\/bit-\/electronix/Aurora-\/SDK -\/-\/recurse-\/submodules}

\end{DoxyCode}


Once its done you\textquotesingle{}ll have an Aurora-\/\+SDK full of everything you need to start writing your own code.\hypertarget{index_autotoc_md11}{}\doxysubsection{Building the Libraries}\label{index_autotoc_md11}
The Aurora-\/\+SDK uses a few libraries to interface with the hardware, and provide a bunch of DSP that can be used within your projects. These need to be compiled before we can build any examples.

The only time, other than after cloning the repo, that this needs to happen is when updating the libraries to a newer version.

If you\textquotesingle{}re using VS Code you can open the task menu by clicking\+: {\ttfamily Terminal-\/\texorpdfstring{$>$}{>}Run Task...} and selecting \char`\"{}\+Build Libraries\char`\"{} from the menu.

This is the equivalent of running the following command in a terminal from the Aurora-\/\+SDK\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{./ci/build\_libs.sh}

\end{DoxyCode}
\hypertarget{index_autotoc_md12}{}\doxysubsection{Building the Examples}\label{index_autotoc_md12}
Each example is a single C++ file, and a {\ttfamily Makefile}.

If you\textquotesingle{}re using VS Code, you can build all examples by running the build task by clicking\+: {\ttfamily Terminal-\/\texorpdfstring{$>$}{>}Run Build Task...}. The shortcut for this is {\ttfamily CTRL+\+SHIFT+B} on Windows, or {\ttfamily CMD+\+SHIFT+B} on Mac OS.

Alternatively, using the same task menu as above, you can build individual examples, for example, the task, {\ttfamily Build Example -\/ Blink} will build the Blink example.

This is the equivalent of running the following command in a terminal from the specific Example\textquotesingle{}s folder\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{make}

\end{DoxyCode}
\hypertarget{index_autotoc_md13}{}\doxysection{Going Further}\label{index_autotoc_md13}
Now that we can compile the provided examples, let\textquotesingle{}s look at where we might want to go from here.\hypertarget{index_autotoc_md14}{}\doxysubsection{Copying and Modifying an Example}\label{index_autotoc_md14}
A great starting point is to copy one of the existing examples, and making modifications.

For example, a good first modification to any of the existing examples would be to add the corresponding CV input to one of the knob controls.

Since the examples are only a pair of files each, all you really need to do is Copy/\+Paste the folder and change the name.

In the {\ttfamily Makefile} you\textquotesingle{}ll want to\+:


\begin{DoxyItemize}
\item update the {\ttfamily TARGET} name (on line 2)
\item and the {\ttfamily CPP\+\_\+\+SOURCES} filename (on line 8) if you change the cpp file name.
\end{DoxyItemize}

To build your new file you\textquotesingle{}ll either need to edit the {\ttfamily .vscode/tasks.\+json} file (copying the entry for \char`\"{}\+Build Example -\/ X\char`\"{} to your new folder name), or to run the {\ttfamily make} command directly from the terminal\hypertarget{index_autotoc_md15}{}\doxysubsection{Creating Your Own Firmware Project}\label{index_autotoc_md15}
Once you\textquotesingle{}ve dabbled a bit, and want to make your own custom firmware for yourself (or to share with the community), you can set some stuff up to start making your own folders.

If you\textquotesingle{}re keeping your new project in the {\ttfamily Examples} folder you won\textquotesingle{}t have to change much other than what was mentioned above.

However, if you want to have a dedicated folder (perhaps a github repo of your own) to keep your project, you may want to have your source files {\itshape outside} of the Aurora-\/\+SDK folder.

In this situation, the only other thing you\textquotesingle{}ll want to update is the {\ttfamily AURORA\+\_\+\+SDK} path (line 13) of the Makefile to point to a copy of the Aurora-\/\+SDK somewhere on your comptuer. This path can be relative, or absolute.

If you\textquotesingle{}re making you\textquotesingle{}re making your project a github repo. You can add the SDK to your own repo as a submodule using\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{git submodule add https://github.com/qu-\/bit-\/electronix/Aurora-\/SDK}

\end{DoxyCode}


and initialize it with\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{git submodule update -\/-\/init}

\end{DoxyCode}
\hypertarget{index_autotoc_md16}{}\doxysubsection{Sharing Firmware With the Community}\label{index_autotoc_md16}
Once you\textquotesingle{}ve got something cool you may want to share the binary, and/or the source code with the community!

The \href{forum.qubitelectronix.com}{\texttt{ Qu-\/\+Bit Forum}} is a great place to share your project along with any details about how it works.

Another great place to share your project is on \href{patchstorage.com}{\texttt{ patchstorage}}. 